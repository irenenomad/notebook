#### 9、桶数排序
###### 时间平均复杂度：O(n*k) 
###### 时间最坏复杂度：O(n*k) 
###### 时间最好复杂度：O(n*k) 
###### 空间复杂度：O(n+k) 
````js
function insertionSort(array) {
  const { length } = array;
  let temp;
  //第一层循环控制循环比较的终点位置
  for (let i=1; i<length; i++) {
    let j=i;
    //把终点位置的值取出暂时存放，为往后循环挪动留出空间
    temp=array[i];
    //循环往后挪动的条件是比暂时存放的值要大
    while (j>0 && (array[j-1]>temp)) {
      array[j] = array[j-1];
      j--;
    }
    //前面没有比暂时存放的只要大了，就可以插入当前位置了
    array[j] = temp;
  }
  return array;
}
function sortBuckets(buckets) {
  const sortedArray = [];
  //遍历每个桶并用插入排序算法来给每个桶排序，再按桶顺序把排序好的子数组分别push进新数组。
  for (let i=0;i<buckets.length;i++){
    if (buckets[i] != null) {
      insertionSort(buckets[i]);
      sortedArray.push(...buckets[i]);
    }
  }
  return sortedArray;
}

function createBuckets(array,bucketSize) {
  //找出最大最小值
  let minValue = array[0];
  let maxValue = array[0];
  for (let i=1;i<array.length;i++){
    if (array[i] < minValue) {
      minValue = array[i];
    } else if (array[i] > maxValue) {
      maxValue = array[i];
    }
  }
  //计算桶的个数
  const bucketCount = Math.floor((maxValue-minValue)/bucketSize) + 1;
  //初始化桶
  const buckets = [];
  //给每个桶初始化为空数组
  for (let i=0; i<bucketCount; i++) {
    buckets[i] = [];
  }
  //当前值和最小值的差值除以桶的个数所得的结果来确定push进哪个桶。
  for (let i=0; i<array.length; i++) {
    buckets[Math.floor((array[i]-minValue)/bucketSize)].push(array[i]);
  }
  return buckets;
}
export function bucketSort(array, bucketSize = 5) {
  //数组小于2就可以直接返回数组
  if(array.length < 2) {
    return array;
  }
  //创建桶
  const buckets = createBuckets(bucketSize);
  //用创建好的桶就可以开始排序了
  return sortBuckets(buckets);
}
````
#### 10、基数排序
###### 时间平均复杂度：O(n*k) 
###### 时间最坏复杂度：O(n*k) 
###### 时间最好复杂度：O(n*k) 
###### 空间复杂度：O(n+k) 
````js
//通过当前值和最小值的差值和代表位数的值相除在和10取余，算出该放哪个桶
const getBucketIndex = (value,minValue,significantDigit,radixBase) => Math.floor(((value-minValue)/significantDigit)%radixBase);
const countingSortForRadix = (array,radixBase,significantDigit,minValue) => {
  //初始化桶
  let bucketsIndex;
  const buckets = [];
  const aux = [];
  //设置radixBase个桶给每个桶设置初值为0
  for(let i=0; i<radixBase; i++){
    buckets[i] = 0;
  }
  //根据计算公式得出该放哪个桶，这个桶就加一
  for(let i=0; i<array.length; i++){
    bucketsIndex = getBucketIndex(array[i],minValue,significantDigit,radixBase);
    buckets[bucketsIndex]++;
  }
  //遍历桶，桶的计数结果按顺序累加
  for(let i=1; i<radixBase; i++) {
    buckets[i] +=buckets[i-1];
  }
  //根据计算公式得出是哪个桶，把这个桶的计数减一，再用这个计数作为该数的排序。
  for(let i=array.length-1;i>=0;i--){
    bucketsIndex = getBucketIndex(array[i],minValue,significantDigit,radixBase);
    aux[--buckets[bucketsIndex]] = array[i];
  }
  //把排好序的数组复制回去
  for(let i=0;i<array.length;i++){
    array[i] = aux[i];
  }
  return array
};

//rasixBase十进制
export function radixSort(array,radixBase=10) {
  //找出数组里的最大值和最小值
  let minValue = array[0];
  let maxValue = array[0];
  for (let i=0; i<array.length; i++){
    if(array[i]<minValue) {
      minValue = array[i];
    }else if(array[i]>maxValue){
      maxValue = array[i];
    }
  }
  //循环两次，个位排序一次，十位排序一次
  let significantDigit = 1;
  //循环条件最大值和最小值的差值除位数要大于或等于1，就是说差值要大于两位数，也就是数组里要排序的值肯定有两位数的
  while ((maxValue-minValue)/significantDigit >=1){
    array = countingSortForRadix(array, radixBase, significantDigit, minValue);
    significantDigit *=radixBase;
  }
}
````